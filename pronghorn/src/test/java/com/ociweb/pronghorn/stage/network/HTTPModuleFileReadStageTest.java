package com.ociweb.pronghorn.stage.network;

import static org.junit.Assert.*;

import java.io.File;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

import com.ociweb.pronghorn.network.config.HTTPContentTypeDefaults;
import com.ociweb.pronghorn.network.config.HTTPSpecification;
import com.ociweb.pronghorn.network.config.HTTPVerbDefaults;
import com.ociweb.pronghorn.network.module.FileReadModuleStage;
import com.ociweb.pronghorn.network.schema.HTTPRequestSchema;
import com.ociweb.pronghorn.network.schema.ServerResponseSchema;
import com.ociweb.pronghorn.pipe.Pipe;
import com.ociweb.pronghorn.pipe.PipeConfig;
import com.ociweb.pronghorn.pipe.PipeReader;
import com.ociweb.pronghorn.pipe.util.hash.IntHashTable;
import com.ociweb.pronghorn.pipe.util.hash.IntHashTableVisitor;
import com.ociweb.pronghorn.stage.monitor.PipeMonitorCollectorStage;
import com.ociweb.pronghorn.stage.scheduling.GraphManager;
import com.ociweb.pronghorn.stage.scheduling.ThreadPerStageScheduler;
import com.ociweb.pronghorn.stage.test.PipeCleanerStage;

public class HTTPModuleFileReadStageTest {

    
    @Test
    public void usageTest() {
        
        GraphManager gm = new GraphManager();

        //1 -20 gb is not hard to saturate, above this is scales more slowly and it never reaches 40 gb (may work on new PCIe hardware...)
        int fileCount = 20;
        int fileSize = 300;//header is about 72 and this file size MUST not match it or the test will get confused since payload size is used for checking.
        int iterations = 10_000;//500_000;
        HTTPVerbDefaults verb = HTTPVerbDefaults.GET;//HTTPVerbDefaults.HEAD; //HTTPVerbDefaults.GET;
        
        //logger.info("fileSize is "+fileSize);//plus the header
                
        long totalRequests = iterations*(long)fileCount;
        long expectedBytes = totalRequests*fileSize;

        PipeConfig<HTTPRequestSchema> requestConfig = new PipeConfig<HTTPRequestSchema>(HTTPRequestSchema.instance, 100, 80);
        PipeConfig<ServerResponseSchema> responseConfig = new PipeConfig<ServerResponseSchema>(ServerResponseSchema.instance, 10, 4000);
                
        Pipe<HTTPRequestSchema> requestPipe =  new Pipe<HTTPRequestSchema>(requestConfig);
        Pipe<ServerResponseSchema> responsePipe = new Pipe<ServerResponseSchema>(responseConfig);
               
        StaticFileRequestGeneratorStage gs = StaticFileRequestGeneratorStage.newInstance(gm, requestPipe, iterations, fileCount, fileSize, verb);  
        //PipeCleanerStage.newInstance(gm, requestPipe);//generates about 15m req/sec
                
        //can not be watched, does not shutdown.
        FileReadModuleStage<?, ?, ?, ?> watch = FileReadModuleStage.newInstance(gm, requestPipe, responsePipe, HTTPSpecification.defaultSpec(), new File(gs.tempFolder()));

        responsePipe.initBuffers();        
        
        
//        MonitorConsoleStage.attach(gm);        
        GraphManager.enableBatching(gm);
        
        
        ThreadPerStageScheduler scheduler = new ThreadPerStageScheduler(gm);
        
        
        long start = System.currentTimeMillis();       
        scheduler.startup();  
        
        boolean expectedBody = false;
        long lastChId = -1;
        long runningLen = 0;
        long countedResponses = 0;
        int expectedSequenceNumber = 0;
        long totalFiles = 0;
		while (Pipe.contentRemaining(responsePipe)>0 || (!  (GraphManager.isStageShuttingDown(gm, watch.stageId)||GraphManager.isStageTerminated(gm, watch.stageId))) ) { 
        	while (PipeReader.tryReadFragment(responsePipe)) {
    		        		        		
        		int msgIdx = PipeReader.getMsgIdx(responsePipe);
        		if (-1==msgIdx) {
        			PipeReader.releaseReadLock(responsePipe);
        			break;
        		}
				if (ServerResponseSchema.MSG_SKIP_300==msgIdx) {
					//skip the skip messsage
		    		PipeReader.releaseReadLock(responsePipe);
				} else {        		
					countedResponses++;
	        		assertEquals(ServerResponseSchema.MSG_TOCHANNEL_100, msgIdx);
	        		//Must confirm the data matches
	        		
	        		long channelId = PipeReader.readLong(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_CHANNELID_21);
	        		        		
	        		//sequence number is generated by the orginal request. The response for the file may be delieverd in parts which each will have the same number
	        		int seqNo = PipeReader.readInt(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_SEQUENCENO_23);
	        		assertTrue(seqNo==expectedSequenceNumber || (seqNo==(expectedSequenceNumber+1)));
	        		
	        		if (expectedSequenceNumber!=seqNo) {        	
	        			assertTrue("sent data with header must be larger than the file size alone",runningLen>fileSize);
	        		
	        			//start new running len;
	        			runningLen = 0;
	        			expectedSequenceNumber=seqNo;        			
	        		}        		      	       		
	        		
	        		long length = PipeReader.readBytesLength(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_PAYLOAD_25);

	        		boolean isBody = (fileSize==length);
	        		assertEquals(expectedBody, isBody);
	        		expectedBody = !isBody; //if we got a body we expect a header, if we got a header we expect a body.
	        		if (isBody) {
	        			totalFiles++;
	        			assertEquals(lastChId, channelId);
	        		} else {
	        			assertFalse(lastChId+" vs "+channelId,lastChId==channelId);
	        		}
	        	
	        		//show the headers in the console
//	        		if (!isBody) {
//	        			PipeReader.readUTF8(responsePipe, ServerResponseSchema.MSG_TOCHANNEL_100_FIELD_PAYLOAD_25, System.out);
//	        		}
	        		
	        		lastChId = channelId;
	        		runningLen += length;
	        		
	        		
		    		PipeReader.releaseReadLock(responsePipe);
				}
	    	}

		}
		               
        scheduler.awaitTermination(60, TimeUnit.MINUTES);      
                
        assertEquals(totalRequests, totalFiles);
        
        long duration = System.currentTimeMillis()-start;
        float requestPerMsSecond = totalRequests/(float)duration;
      //  System.out.println("totalFileRequests: "+totalRequests+" perMs:"+requestPerMsSecond+" duration:"+duration);
      //  System.out.println("data bytes:"+expectedBytes+" plus headers");
        
        
    }
    
    //TODO: add generator for fuzz test of invalid file name.
    
    @Test
    public void testFileExtCollide() {
        final AtomicInteger count = new AtomicInteger();
        
        IntHashTableVisitor visitor = new IntHashTableVisitor(){

          @Override
          public void visit(int key, int value) {
             //System.out.println("key "+key+" value "+value);
             
             HTTPContentTypeDefaults type = HTTPContentTypeDefaults.values()[value];
             
             Assert.assertEquals( HTTPSpecification.extHash(type.fileExtension()), key);

             count.incrementAndGet();             
              
          }
          
       };
      IntHashTable.visit(HTTPSpecification.defaultSpec().fileExtHashTable, visitor );
      
      int c = HTTPContentTypeDefaults.values().length;
      int total = 0;
      while (--c>=0) {
          if (!HTTPContentTypeDefaults.values()[c].isAlias()) {
              total++;
          }
      }      
      Assert.assertEquals(count.get(),total);
      
    }
    
    @Ignore
    public void rapidValidReadLoadTest() {
        
        GraphManager gm = new GraphManager();

        //1 -20 gb is not hard to saturate, above this is scales more slowly and it never reaches 40 gb (may work on new PCIe hardware...)
        int fileCount = 20;
        int fileSize = 300;//selected to make the output 20gbs
        int iterations = 100_000;//500_000;
        HTTPVerbDefaults verb = HTTPVerbDefaults.GET;//HTTPVerbDefaults.HEAD; //HTTPVerbDefaults.GET;
        
        //logger.info("fileSize is "+fileSize);//plus the header
                
        long totalRequests = iterations*(long)fileCount;
        long expectedBytes = totalRequests*fileSize;

        PipeConfig<HTTPRequestSchema> requestConfig = new PipeConfig<HTTPRequestSchema>(HTTPRequestSchema.instance, 100, 80);
        PipeConfig<ServerResponseSchema> responseConfig = new PipeConfig<ServerResponseSchema>(ServerResponseSchema.instance, 10, 4000);
                
        Pipe<HTTPRequestSchema> requestPipe =  new Pipe<HTTPRequestSchema>(requestConfig);
        Pipe<ServerResponseSchema> responsePipe = new Pipe<ServerResponseSchema>(responseConfig);
               
        StaticFileRequestGeneratorStage gs = StaticFileRequestGeneratorStage.newInstance(gm, requestPipe, iterations, fileCount, fileSize, verb);  
        //PipeCleanerStage.newInstance(gm, requestPipe);//generates about 15m req/sec
                
        //can not be watched, does not shutdown.
        FileReadModuleStage<?, ?, ?, ?> watch = FileReadModuleStage.newInstance(gm, requestPipe, responsePipe, HTTPSpecification.defaultSpec(), new File(gs.tempFolder()));

        responsePipe.initBuffers();        
        
        
//        MonitorConsoleStage.attach(gm);        
        GraphManager.enableBatching(gm);
        
        
        ThreadPerStageScheduler scheduler = new ThreadPerStageScheduler(gm);
        
        
        long start = System.currentTimeMillis();       
        scheduler.startup();  
        
		while (Pipe.contentRemaining(responsePipe)>0 || (!  (GraphManager.isStageShuttingDown(gm, watch.stageId)||GraphManager.isStageTerminated(gm, watch.stageId))) ) { 
        
			
			while (PipeReader.tryReadFragment(responsePipe)) {
           		int msgIdx = PipeReader.getMsgIdx(responsePipe);
				if (ServerResponseSchema.MSG_SKIP_300==msgIdx) {
					//skip the skip messsage
		    		PipeReader.releaseReadLock(responsePipe);
				} else { 
		    		PipeReader.releaseReadLock(responsePipe);
				}
	    	}
        	Thread.yield();
		}
        
        scheduler.shutdown();       
        scheduler.awaitTermination(60, TimeUnit.SECONDS);      
                
        
        long duration = System.currentTimeMillis()-start;
        float requestPerMsSecond = totalRequests/(float)duration;
       // System.out.println("totalFileRequests: "+totalRequests+" perMs:"+requestPerMsSecond+" duration:"+duration);
       // System.out.println("data bytes:"+expectedBytes+" plus headers");
              
    }
    
}
